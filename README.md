数据库中的用户名是blue
密码是123456
登陆的后台只有banner设置，用户评价功能
·····························································
后台部分
登陆：http://localhost:8080/admin/login
登陆成功：http://localhost:8080/admin/
banner设置：http://localhost:8080/admin/banners
用户评价：http://localhost:8080/admin/custom

在static的index.html中，它获取了banners和用户评价中的数据，但是这里使用了前端框架Angular。有些代码我还看不懂。

前台部分

地址栏访问localhost:8080/get_banners可获取banners的数据
localhost:8080/get_custom_evaluations可获取custom的数据



## 主要实现功能：

1.用户名密码登录
2.增删改查管理员发布的网页数据

## 具体小功能：

1.对用户名数据进行哈希加密（签名）
2.强制登录页面（重定向）
3.浏览器与服务器传输数据



# libs/common.js

该文件封装模板，其功能是将登录时的用户输入的用户名密码等数据用哈希算法加密（签名），让该数据不可见，避免他人获取用户名密码。

其中，MD5_SUFFIX加在数据后面，再进行md5加密，该MD5_SUFFIX是自定义的数据的 

# /route/index.js

在服务器运行后，服务器一直监听8080端口，当有请求访问，首先对该用户的登录状态和请求进行判定，如果不是管理
员，就重定向返回登录界面。如果想访问其他页面，也不行，重定向回登录界面。只有当既是管理员，请求访问的又是
登录界面才对请求予以响应。

如果已确定是管理员，就再来判定其访问请求。 



# /route/login.js

那是怎么判断是否为管理员？
当管理员登录时，后台就拿着页面获取的用户名密码和数据库的进行比对，成功就给浏览器发session，不成功就不发，
判定管理员的时候就是看有没有session。
为什么不直接不直接用用户名密码验证，而要再加一个session？
session可以理解为cookie的加强版，具有生存期，可以控制用户在一定时间内免登陆。若采用用户名密码验证，那每
退一次，就得输入一次密码，这在实际操作中是很不方便的。



# route和template

登录后，就对数据进行操作。route和template分别是存放js和静态文件的文件夹，文件夹内的js文件实现的功能相似，都是将页面和数据库连接起来，对数据进行增删改查的操作。就banners页面来说，其具体代码如下：

sql文件就不上传了